apiVersion: v1
data:
  core-entroq-authz.rego: |
    # The core rules in this file are _always_ present in the system.
    # This file deals with the input, which is fixed-format and determined
    # by the needs of the EntroQ system itself.
    #
    # The data, on the other hand, can come from various places, optionally.
    # It is possible for example, to bring information about users, roles, and
    # privileges in from another server entirely, all within Rego code. We enable
    # this flexibility by keeping the data-specific processing separate from the
    # non-optional user-request processing.
    #
    # A working implementation comes from importing two things from a package named
    # entroq.permissions:
    #
    # - username: a complete rule producing a string containing the name of the
    #       user (a user ID).
    # - allowed_queues: a partial rule producing all allowed queue specifications
    #       for this user ID.
    #
    # How these are obtained is up to the deployer of the service. A default
    # configuration is given in default-permissions.rego. Comments there indicate
    # the shape of the data that it works with.
    package entroq.authz

    import data.entroq.queues
    import data.entroq.permissions.allowed_queues
    import data.entroq.permissions.username

    failed_queues[q] {
      q := queues.disallowed(input.queues, allowed_queues)[_]
    }

    queues_result := {
      "user": username,
      "failed": failed_queues
    }

    allow {
      count(failed_queues) == 0
    }
  core-entroq-queues.rego: |
    package entroq.queues

    # This package operates on queues and sets of queue specs.
    # Queue specs are expected to look like this:
    # {
    #   "exact": "/exact/name/of/queue",
    #   "actions": ["CLAIM", "READ"],
    # }
    #
    # Instead of "exact", a queue may have "prefix". Actions are strings. Currently allowed are
    # - READ
    # - CHANGE
    # - CLAIM
    # - INSERT
    # - DELETE
    # - ALL
    #
    # Though the only special action above is "ALL", and it is treated as though it contains
    # all of the actions that can be had (allows anything to match it).

    # name_match returns true if "want" is match by "can" in a way that would
    # permit this queue to be considered for use by a user requesting it.
    #
    # - want: a queue spec representing a queue (or queue pattern) the user wishes to use
    # - can: a queue spec representing a queue or pattern the data allows.
    #
    # Use this to find out which "allowed" queue specs pertain to a given user queue request.
    name_match(want, can) {
      want.exact == can.exact
    }
    name_match(want, can) {
      startswith(want.exact, can.prefix)
    }
    name_match(want, can) {
      startswith(want.prefix, can.prefix)
    }

    # has_wildcard indicates whether a set contains a wildcard, like ALL, ANY, or *.
    has_wildcard(actions) {
      actions[["*", "ALL", "ANY"][_]]
    }
    # actions_left returns actions in "want" that are not covered by actions in "can".
    #
    # Use this on the actions of a particular user queue request and a matching
    # queue allowance from the data. Best when used only after a positive name_match
    #
    # If "can" is a wildcard, always returns the empty set (all are allowed, none are left).
    #
    # - want: a set of action strings that the user wishes to perform.
    # - can: a set of action strings that might be allowed.
    actions_left(want, can) = x {
      x := {y | y := (want - can)[_]; not has_wildcard(can)}
    }

    # disallowed returns a set of queue specs, with actions filled in
    # that are not covered by any of the given allowances.
    #
    # - want: a set of queue specs that the user wants to authorize.
    # - can: a set of queue specs that are allowed for this user.
    disallowed(want, can) = results {
      results := {q |
        want_q := want[_]
        want_actions := {a | a := want_q.actions[_]}
        can_actions := {aq.actions[_] | aq := can[_]; name_match(want_q, aq)}

        left := actions_left(want_actions, can_actions)
        count(left) > 0

        q := object.union(
          object.remove(want_q, ["actions"]), {"actions": left}
        )
      }
    }
kind: ConfigMap
metadata:
  name: eqopa-core
